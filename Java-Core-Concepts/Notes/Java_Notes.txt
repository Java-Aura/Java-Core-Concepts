

1. Java Virtual Machine(JVM):

 i) writing phase --- the programmer will write the code.(Test.Java)
 ii) compilation phase --- javac is the compiler which will compile the source code to byte code(Test.class).
 iii) execution phase --- Java runtime environment (JRE) will execute the byte code.

2. Bytecode in the Development process: javac is the compiler which will compile the source code to byte code(Test.class). javap is the command to see the methods of the class.
 
3. Java Development Kit(JDK):  

	i) Java development tool kit : Which includes JRE,JAVAC and JAVA Debugger , Java docs. 
	ii) JDK is the platform dependent 
	
	Note : JDK is the platform dependent but the code generated by Java compiler is the platform independent 

4. Java Runtime Environment (JRE): 

	i) with JRE the byte code which is generated using compiler will be executed.

5. Garbage Collector: the programmer can't destroy the objects but we can specify the objects to be garbage collected.

6. ClassPath: is the path where the Java runtime and compiler will look .class files.

After installing JDK we have to set path : C:\Program Files\Java\jdk-17.0.2\bin;.

Features 
===============

1. Platform Independent:  

We can run the Java program in platform and compile it after compilation .class file will be generated. we can run this .class file in ant platform, this makes Java as a platform independent.

to execute .class the platform should have JRE.
Compile the code in one platform and run it in any of platforms in which the JRE installed.

2. Object-Oriented Programming Language(OOPS): collecting Java program in objects.

	1)Abstraction
	2)Encapsulation
	3)Inheritance
	4)Polymorphism


3. Simple: in Java we don't have pointers,Operator overloading,and Multiple inheritance is also not there then this makes Java as simple.

4. Robust: Java is more reliable. in Java we can fix most of the errors in compilation state this makes Java is robust.

5. Secure:  in Java we don't pointers(pointers refer the address location of the objects which is not secure).

6. Distributed: we can distribute Java application through network. we have Enterprise Java beans(EJB) and remote method invocation(RMI)

7. Multithreading: Executing program by multiple threads.

8. Portable: after compilation .class file will be generated this file we can send to any platform which makes Java as a portable.


Java Programming Format
============================

Every Java programmer should follow the coding format.

	1)Documentation Section:
		this is the section we can add comments for methods.variables etc. which makes the programmer more readable 
		i) Single line comments ex: // single line comments
		ii) Multi line comments ex : /* Multiline comment
		iii) Documentation comments ex: /** documentation comments */
		
		Note: Compiler will ignore the comments.
		
	2)Package Section : In Java we can collect multiple classes as collection is known as package. we can declare package using package keyword.
		syntax: package <package-name>;
		
	3)Import Section : In Java we have predefined classes if we want to use them then we have to import in out programme.
						*) import members from one package into current running program
						syntax: 
								import <package-name>.<class-name>.method-name();
	
	4)Interface Section : in this section we can declare interface(interface can be used to achieve multiple inheritance in Java)
							
							syntax:
										interface <interface-name>;
							
	5)Class section : in this section we can declare classes. we can declare n number of classes in a single Java file.
			
						syntax: 
						
									class <class-name>{
									
									}
	
	
	6)Main method class  : In Java execution starts from main method.
		signature : public static void main(String a[]){
															}
															
																	
	7) methods: is a function which execute some logic

				syntax: 
							<access-modifier> <return-type> <method-name>(){
							
							}
							

Simple java program:


			public class MainClass{
			
			public static void main(String args[]){ 
			
			System.out.println("First java program");
			
			}

			}
			
			main method signature: main method signature is the default signature and with out main method we can't run execute java program.
				public: makes the main available within the project 
				static: Can be accessed with class name directly
				void: return nothing, the main method should not return any value.
				main: method name
				String[]:  the main method should be declared with string array which is ready to accept any type of data
				
			System.out.println: 
			
			System: System is the class available from java.lang package. and this System class has three fields
			
					1)in:  can be used to read input from the user/keyboard.
					2)out: can be used to display the message on console
					3)err: can be used to display error messages.
					
			println() : can be used print message on console. this method print the message and cursor waits in the next line
			print(): this method print the message and cursor waits in the same line.
			
		Ex:	public class SystemClass {

	public static void main(String[] args) {
		
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter message:");
		String message = sc.nextLine();
		System.out.println(message);

	}

}

Scanner: is the class from java.util package and can be used to read data from keyboard or from any file resource.

			Scanner sc = new Scanner(System.in);
			String message = sc.nextLine(); // for reading string type of data.
			int i = sc.nextInt(); // to read integer type of data.

2)Package Section : In Java we can collect multiple classes as collection is known as package. we can declare package using package keyword.
		syntax: package <package-name>;
		
		user-defined packages: the packages which are declared by the programmer 
		
		syntax: package <package-name>;
		
		pre-defined packages: The packages which are already defined in java programming language
							
							Ex: 
								1)java.lang(language): is the default package, will have all the classes and methods required for default java program.
								2)java.util(utility package): 
								3)java.net(networking):
								4)java.io(input and output):
								
Note : to see the methods available from class use the below syntax
		
		syntax: javap java.util.Scanner
		
				javap: is the keyword to see the methods from the class
				
				
Java Tokens
============

1) Keywords: keywords are reserved words in Java we can't use them for variable name, method name, etc. ex: break, continue,class, interface, int, void, public, private etc.

2) identifiers: means giving name to variables, methods,classes etc.

 standards we should follow : identifier name should start with letter, dollar symbol. 
							  underscore, apart from this we can have any character, case sensitive, and can't start with digit but inside we can have digits.
							  we should not use keywords as identifiers.
							  

3) Literals: means constants that means once defined can't be changed. we can declare constants in Java using final keyword.

		Ex:  final int k=20;
			 k=34; // Compile time exception: the final local variable k cannot be assigned. It must be blank and not using a compound assignment
			 
			 String literal: String str = "test";

4) Operators: can be used to perform certain operation on variables.

	Arithmetic : +,-,/,%.* ==> can be used to perform Arithmetic operations
	unary : ++,--,! ==> can be used to perform increment/decrement operations
	
				Increment: can be used to increment the value by one.
				
							post-increment: first display the value and increment the value
							pre-increment: first increment the value by one and then display it.
							
				Decrement: can be used to decrease the value by one.
				
							post-decrement: first display the value and decrement the value
							pre-decrement: first decrement the value by one and then display it.
							
							
		Ex:
		
		
					int i = 30;
					int k = 34;	
		
		// unary : ++,--,! ==> can be used to perform increment/decrement operations
		System.out.println(++i); // pre-increment = 31
		System.out.println(i++); // post-increment.. == 32 after display the value will be incremented by one
		System.out.println(i); // 32
		
		/*
		 * Decrement: can be used to decrease the value by one.
		 */
		
		System.out.println(--k);  // 33 pre-decrement: first decrement the value by one and then display it.
		System.out.println(k--);  // 33 post-decrement: first display the value and decrement the value
		System.out.println(k); // 32
			      
	assignment : =, +=,-=,/=,%=,*=  ==> can be used to assign values to variables.
							
							EX: 
							
									// assignment : =, +=,-=,/=,%=,*=  ==> can be used to assign values to variables.
		
										int j = 10; 
										j += 12; // same as j = j+12 which is 22
										j -= 10; // same as j = j-10 which 12
					
	relational: <,> <=,>=, == returns true/false ==> can be used to copare the values(find the equality/ greater than/less than etc). return true/ false
	
	
					EX: 
										int h = 12;
										int t = 23;
										System.out.println(h>t); // false
										System.out.println(t>h); // true
										int g = 12;
										int d = 12;
										int n = 9;
										System.out.println(g==d); // true
										System.out.println(g>h); // false
										System.out.println(g>=h); // true
										System.out.println(n<=g); // true
												
				
						
	Ternary : which is alternative for if else. ==> can be used to assign values to variables based on some condition
	
				Syntax:
						<data-type> <variable-name> = (condition) ? <some-value> : <some-value>;
					
	bitwise : &, |,^, ~ ==> can be used to perform bitwise comparison between operands.
	
		operands: operands are values can be used to perform some operations.
		
			EX:
			
								//bitwise : &, |,^, ~ ==> can be used to perform bitwise comparison between operands.
								
								int bit1 = 10;
								int bit2= 12;
								int a =5;
								
								System.out.println(Integer.toBinaryString(bit1));
								System.out.println(Integer.toBinaryString(bit2));
								System.out.println(Integer.toBinaryString(-6));
								System.out.println("(bit1 & bit2) parseInt = "+Integer.parseInt("1000", 2)); //bit1 & bit2
								System.out.println("(bit1 | bit2) parseInt = "+Integer.parseInt("1110", 2)); // (bit1 | bit2
					
								
								System.out.println("(bit1 & bit2) = " + (bit1 & bit2));
								System.out.println("(bit1 | bit2) = " + (bit1 | bit2));
								System.out.println(~a);
								
								     1010
(and)1100
     ======
     1000

    1010
(or)1100
    ======
    1110
		

5) Symbols: special characters in Java which having special meaning.

 [] : this is for declaring Array of elements.
 ex: int arr[];
 {} : this is for to declare block of statements.
   ex:
			{
			  // statements
			}
 () : can be used to declare methods,constructors.
		ex: public void method1(){
		
		}
 , : can be used to separate variables, or statements.
 
		ex: int i,k,l;
 ; : can be used to specify end of the statement.
		ex: int k =10;
 * : pointer variable in Java
	
	ex: import java.util.*; // all the classes and interfaces are available to current running program
 
Data Types : data types can be used to specify what type of data that variable can hold.

		ex: int k ="string"; // compile time error. because the variable k should hold only integer type of data.
			int k =10;/  no compile time error.
			
			data types are two types.
			1) Primitive data types.
			2) Non-primitive(user defined) data types.
 
 1)Primitive data types: These are the data types already defined in Java programming language.
 
	Boolean Type: boolean (true/false) default value is false size is 1 bit
			ex: boolean b = true;
	
	Numeric Type: 
		
		Character: 
				char: default values is \u0000 size is 2 bytes(16 bits), can be declared using single quotes.
					  ex: char c = 'A'; 
						  char c = '65';
		
		 Integer: 
			
			Integer: 
				
				byte: default value is 0 and size 8 bits(1 byte) range is -128 to 127
				short: default value is 0 and size 16 bits(2 bytes) range is -32768 to 32767
				int: default value is 0 and size 32 bits(4 bytes) range -2147483648 to 2147483647
				long: default value is 0 and size 64 bits (8 bytes) 
			
			Floating point: 
				
				float: default value is 0.0 size is 32 bits(4 bytes)
				double: default value is 0.0 size is 64 bits(8 bytes)
				
				ex: 
				
							byte b = 127; // byte data type.
							
							short s = 13; // 
							
							int i = 14;
							
							long l = 367;
							
							float f = 32.4f;
							
							double d = 32.7;
							
							char c = 'k';
							
							boolean b1 = true;
	
 
 2)Non-primitive(user defined) data types: Data types which are not defined in Java programming language(programmer can defined) except String.
										   for all the non-primitive data types the default value is null.
 
	ex : String, Arrays,Class user defined objects etc.
	
	differences :
	
		1) primitive date types are already by defined by the java programming language. where as non-primitive date types are not defined
		2) primitive data types start with lowercase letter, where as non-primitive data types start with uppercase letter.
			ex : String, Arrays
		3) With non-primitive data types we can call methods. but using primitive data types we can't.
			ex: String str = "test";
				str = str.toUpperCase();
				char c = 't'; // no methods available
		3) primitive data types always has some value.but non-primitive data types can be null.
		4) primitive data types size is based on the data types, where as non-primitive data types have all the same size.
		
		
		Ex: 
		
						public class DataTypes {

						
						int p;
						String j;
						int arr[];
						public static void main(String[] args) {
							
							byte b = 127; // byte data type.
							
							short s = 13; // 
							
							int i = 14;
							
							long l = 367;
							
							float f = 32.4f;
							
							double d = 32.7;
							
							char c = 'k';
							
							boolean b1 = true;
						
							String str = "test";
							str = str.toUpperCase();
							
							System.out.println(new DataTypes().p);
							System.out.println(new DataTypes().j);
							System.out.println(new DataTypes().arr);
							
							System.out.println(str);
							
							System.out.println("byte: "+b);
							System.out.println("short: "+s);
							
							System.out.println("int: "+i);
							System.out.println("long: "+l);
							System.out.println("float: "+f);
							System.out.println("double: "+d);
							System.out.println("char: "+c);
							System.out.println("boolean: "+b1);

						}

					}
					
					
Types of Variables : variable 
=============================

Definition : Variable are data holders, which can hold specified data.

	Syntax: 
				declaration:  <data-type> <variable-name>;
				assign value: <data-type> <variable-name> = <value>;
				
				

variables in Java are two types:

	1) Static Variables: the variables which are declared using static keyword are known as static variables.
						 static variables can be accessed using class name directly
						 static variables are available at class level. due to this we can access from class directly.
						 static variables are created at the starting of the program and destroyed at the end of the execution.
						 Initialization of static variables is not mandatory.JVM will assign default values.
						 if we access static variable without class name then the compiler append the class name automatically.
						 and if we access static variable with object reference then compiler will show warning.
						 we can initialize static variables inside static block or at the time declaration.
						 static variables are available for all the objects created for the class.
						 
		Note: static variables should not be declared as local(within the method,constructor,block).
	
		syntax : static <data-type> <variable-name>;
		ex: static int k = 20;
	
	2) Non-Static Variables:
								1)instance Variable : 
								2)Local Variable : 




						1)instance Variable : The variables which are declared inside class but outside the method,constructor,block. The variables which are declare without static keyword are known as instance variables,
							 instance Variables Can be accessed using Object of the class.
							 instance variables are created at the time object creation and destroyed when the object is destroyed.
							 Initialization of instance variables is not mandatory.JVM will assign default values.
							 we can initialize instance variables inside instance(non-static) block, constructor or at the time declaration.
							 Instance variables are available for created object and specific to that object only.that means the changes made in object variable will not be effected on another object.
	
	
							syntax :  <data-type> <variable-name>;
							Ex: int k = 20;
		
						2)Local Variable : The variables declared inside the method,constructor or block known as local variables.
						   Local variables must be assign some value, JVM will not assign default values to local variables.
						   Local variables are available with the block,constructor or method. that means outside we can't access.
						   
						   Syntax : 
						   
										public void methodName(){
											
											int k =90; //local variable.
										}
		
		
			
			
			Ex:
			
															public class TypeOfVariables {

											public static void main(String[] args) {
												
												VariableTypes obj = new VariableTypes();
												obj.nonStaticVariable = "nonStaticVariable value changed for obj";
												System.out.println(obj.nonStaticVariable); 
												
												VariableTypes obj1 = new VariableTypes();
												System.out.println(obj1.nonStaticVariable);
												
												System.out.println(obj.staticVaraible); // accessed with class name
												System.out.println(VariableTypes.staticVaraible);
												//System.out.println(VariableTypes.nonStaticVariable); // we can't access by class name as it is a instance variable
												//System.out.println(obj.methodName().localVariable); // local variables are not available outside of method.
												obj.nonStaticMethod();
												obj.staticMethod(); // gives warning
												VariableTypes.staticMethod();
												System.out.println(obj.nonStaticInitialization);
												System.out.println(obj.nonStaticInitializationFromConstructor);
												System.out.println(VariableTypes.staticInitialization);
												
												
												
											}

										}
										class VariableTypes{
											
											static String staticVaraible = "staticVaraible"; // static variable
											String nonStaticVariable = "nonStaticVariable";
											
											String nonStaticInitialization;
											String nonStaticInitializationFromConstructor;
											static String staticInitialization;
											
											{
												nonStaticInitialization = "nonStaticInitialization from not-static block";
											}
											static {
												staticInitialization = "staticInitialization from static block";
											}
											
											/* constructor*/
											public VariableTypes() {
												nonStaticInitializationFromConstructor = "nonStaticInitialization from constructor";
											}
											
											/*non-static method */
											public void nonStaticMethod() {
												System.out.println("Non-Static method execution");
												//static String localStatic = "test";local static can't be possible
												String localVariable = "localVariable";
												
											}
											/*static method */
											public static void staticMethod() {
												//static String localStatic = "test"; local static can't be possible
												System.out.println("Static method execution");
											}
											
										}
										
Expression : 

An expression made up of data types, variables, operators, and calling methods.

ex: int k =10; // assigning value 
	Test obj = new Test(); // creating object for the Test class
	obj.display(); // calling methods
	String str; // declaring String variable



Statements : 	Statements are equivalent to sentences. Statements forms a unit of execution. The statements are declared inside flower brackets{(open) }(close)

		syntax :
		{
			// statements
		}

	Declaration statements: These statements can be used to declare the variables
		ex : int k;
	
	Expression Statements: these statements are ended with semicolon ; and can perform some operation.
			ex: int k =10 // expression
			k++;
			k--;
			int k =23; //  statement
			
	ControlFlow Statements : The Statements which are used to control the flow of execution.
	
	
			i) Conditional statements: The statements which can be used to control the flow of execution with some condition known as conditional statements
			
			if : can be used to executes statements based on condition
			
				Syntax : if(condition){
								// statements
							}
			else : can be used to execute statements if the if condition not satisfied.
			
					Syntax : 
								if(condition){
									// statements
								}	
								else{
										// statements
								}
			else if : if the if condition not true then we can use else if to check for another condition.
			
					if(condition){
									// statements
								}	
								
								else if (condition){
									// statements
								}
								else{
										// statements
								}
			nested if: writing more than one if condition and it will check for all the if condition
			
					syntax : 
					
							if(condition){
									// statements
								}	
								if(condition){
									// statements
								}	if(condition){
									// statements
								}	
							

			nested else if: writing more than one else if condition and it will check else if conditions followed by condition
						
								syntax : 
								
										if(condition){
												// statements
											}	
											else if(condition){
												// statements
											}	else if(condition){
												// statements
											}								
								
								
					
						
			switch : alternate for if, else if, else. this statement can have multiple execution paths. can be used switch over some value.
					Note: if none of the case satisfied then default case will be executed. and we can't use relational operators for switch case 
							if we don't use break and if all the cases are satisfied the all cases will be executed, and there is no need of using break for default statement because it's a last case.
			
				Syntax : 
							int value = 10;
							switch(value){
							
							case <value>: 
							// statements
								break;
								
							case <value2>:
							// statements
							break;
							
							default:
							// statements
							
							}
							
					EX:
					
								public class ConditionlStatements {

										public static void main(String[] args) {
											
											Scanner sc = new Scanner(System.in);
											System.out.println("Enter age");
											int age = sc.nextInt();
										
											/*Conditional statements:*/
											if(age>=18) {
												System.out.println("User can able to vote");
											}
											else if(age>=17 && age<18) {
												System.out.println("User has to wait for one more year");
											}
											//nested else if
											else if(age<16) {
												System.out.println("User is a child");
												
											}
											else {
												System.out.println("User can't vote");
											}
											
											//nested if
											
											if(age>18) {
												System.out.println("nested age greater than 18");
											}
											if(age>=18) {
												System.out.println("nested age greater than or equals to 18");
											}
											if(age<18) {
												System.out.println("nested age less than 18");
											}
											switch (age) {
											case 18: 
													System.out.println("switch case: user can vote");
													break;
											case 17:
												System.out.println("switch case: user has to wait for one more year");
												break;
											case 15:
												System.out.println("switch case: user is a child");
												break;
											default:
												System.out.println("none of the case satisfied");
											}
											
										}

									}
		
		ii) Looping Statements: can be used to iterate(retrieve) array or collections over some condition
		
			for :  this statement can be used iterate over a range of values until the particular condition is true.
			
				Syntax:  for(<data-type> <variable-name> = <initialization>; <condition>; <inc/dec>){
				 // statements
				 
				 }
				 
			foreach/ extended for loop: same as for loop but we can't add any conditions while iterating
					
					Syntax: for(<data-type> <variable-name> : array/collection object){
					// statements
					}
			
			while: this statement can be used to execute set of statements until the particular condition is true.
			
			Syntax: 
			
						while(condition){
						// statements
						}
			
			do while:  this statement is like while statement but while statement will be executed if the condition is true,
					   but do while will executes the statements at least once if the condition is true or false.
					   
					   Syntax:
					   
									do{
									// statements
									}
									while(condition);
									
									
					EX:
					
															
									public class LoopingStatements {

											public static void main(String[] args) {
												
												Scanner sc = new Scanner(System.in);
												System.out.println("Enter number to print table");
												int num = sc.nextInt();
												System.out.println("printing table from for loop");
												for(int i=1;i<=10;i++) {
													System.out.println(num+ "*"+ i + " = "+ num*i);
												}
												int arr[] = new int[] {12,23,45};
												int arr1[] = new int[] {512,235,453};
												
												//traditional for loop  iterate specific values
												for(int k= 0; k<2;k++) {
													System.out.println(arr[k]);
												}
												// enhanced for loop iterate all values
												for(int j: arr1) {
													System.out.println(j);
												}
												
												int n=1;
												System.out.println("printing table from while loop");
												while(n<=10) {
													
													System.out.println(num+ "*"+ n + " = "+ num*n);
													n++;
												}
												
												System.out.println("printing table from  do while loop");
												System.out.println("value of n after while loop execution = "+ n);
												
												while(n<=10) {
													
													System.out.println(num+ "*"+ n + " = "+ num*n);
													n++;
												}
												
												do {
													System.out.println(num+ "*"+ n + " = "+ num*n);
													n++;
												}
												while(n<10);
												
												do {
													System.out.println(num+ "*"+ n + " = "+ num*n);
													n++;
												}
												while(n<=20);
														

											}

										}
			
		
		iii) Branching statements: These statements can be used to break/ continue the current execution of the program.
		
				break: will stop the current execution of the program
				
				continue:  will skip the current execution and will continue with next execution of statements
				
				return : can be used to return some value after execution.
				
				System.exit(0): to stop/terminating current execution of the program.
				
				
				EX:
				
								public class BranchingStatements {

									public static void main(String[] args) {
										
										BranchingStatements obj = new BranchingStatements();

										obj.printTable();
										
									}
									
									public int getNum() {
										Scanner sc = new Scanner(System.in);
										System.out.println("Enter number to print table");
										int num = sc.nextInt();
										return num;
									}
									
									public void printTable() {
										int num = getNum();
										for(int i=1;i<=10;i++) {
											System.out.println("value of i = "+i);
											if(i==3)
											{
												continue;
												
											}
											else if(i==2) {
												System.exit(0);
											}
											System.out.println(num+ "*"+ i + " = "+ num*i);
											if(i==5) {
												break;
											}
											
										}
									}

								}
				
				
				
JVM
=========
JDK : java development tool kit. which provides JRE, java compiler and provides the environment necessary to run the java program.
	  JDK is the platform dependent.

JRE: IS the java runtime environment which provides environment to run the java program or application


Definition: JVM stands for java virtual machine and it is a part of JRE.
			It run the java program or application
			JVM will convert the byte code(.class) which is generated by java compiler into machine understandable language.and executes it step by step.
			JVM will follow top-down approach
			The first method will load onto the JVM is main method.
			while execution JVM always first looks for main method and if there is no main method then will get runtime exception.
			The execution starts from main method and will follow top-down approach.
			 main method: 
			 
				public static void main(String[] args) {
						
					// block of statements
					int k=20;
						
					}
					
Note: In other programming languages complier will generate the machine code. but in java the compiler will only generate the bye code(.class) which is input to the JVM

javac : javac is the command to compile the java file and to generate .class file for the java file.

java compiler : java compiler can be used to check compile time exceptions and to generate .class file which is input to JVM for execution.


JVM divided into 3 subsystems:

						1) class loader subsystem.
						2) Run time data area.
						3) Execution engine.
						
		
				1) class loader subsystem: Can be used to load, link and initialize the .class file at runtime not compile time.
				
							ex: 
									
											public class JVMTest {

												public static void main(String[] args) {
													// 
													static int k = 20;
													String str = "test";
													System.out.println(str.hashCode());
													

												}

											}
							
				
						
					Load: in this phase the .class file will be loaded
							
							loading can be done in following class loaders :
							
								i) BootStrap class loaders:  Loads the .class file from rt.jar file and the highest priority is given to this loader.(C:\Program Files\Java\jdk1.8.0_202\jre\lib\rt.jar)
					
								ii) Extension class loader: loads the .class files from ext folder. (C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext)
								
								iii) Application class loader. loads the .class files from application class path.(environment variables)
								
								JVMTest .class file will be loaded
					
					Link: 
							
							Verify: In this stage there byteCode verifier will verify the byte code which generated by java compiler is proper or not.
									If the byte code is not proper will get LinkageError.
							
							Prepare: In this stage all static members will get memory and the static variables assigned with default values.
							
										static int k = 0;
										static String str = "null";
										str : user provided reference
							
							Resolve: All symbolic references are replaced with original reference from method area(class area)
							
									static String str = "null";
									str will be replaced by original reference which hashcode of str(3556498)/ address location.
									
									
								
					
							
					
					Initialize: This is the last stage in class loading and this stage all static blocks will be executed and all static variables are assigned with original value
			
										static int k = 20;
										static String str = "test";
										
										
										
2)Run time data area: this area is divided into five types.

		i)Method area/class area
		ii)Heap area/object area
		iii)Java Stack Area
		iv)PC register area
		v)Native method area

		i)Method area/class area: The area which is specific for class known as class area or method area.
								  Here all static programming components will get the memory.
								  And there can be only one method area per JVM
								  And it is a shared resource.shared among all threads
								  
			Note: While class loading the static programming components will get the memory.
				  Once main method got memory it will be loaded onto java stack area for execution.
				  All static members are loaded onto class area(available at class level) that's why we can access static members directly by class name.
				  In java all programming components are either class level(static) or object level(non-static)
				  
				  
		ii)Heap area/object area: This area is for objects.
								  This is the area where all the objects are created.
								  And there can be only one heap area per JVM
								  And it is a shared resource.shared among all threads
								  
								  Note: While object creation all non-static programming components will get the memory, constructor is executed and non-static blocks will be executed,
								  
			
		iii)Java Stack Area: This is the area where all the methods are executed and the first method copied is main method and execution starts from main method.
							 And for every thread a separate run time stack frame/method frame will be created and for every method call one entry will made on stack frame/method frame
							 And in this stack frame/method frame all local variables will get memory. for this reason local variables are available only inside method.
							 
							Stack frame/ method frame is divided into 3 sub entities.
							
								iii.i) Local variable array: This is related to method and all local variables are stored here.
								
								iii.ii) Operand stack: While method execution if any intermediate operation need to be performed then is operand stack acts as workspace to perform that operation
								
								iii.iii) Frame Data: All the symbols related to methods are stored here and in case of any exception the catch block information will be maintained here.
								
										exception: exception is a event which interrupts or disturbs the program to be executed.
										
										
		iv)PC register area: Each thread will have separate pc register area to hold the address of current execution program.
								once the execution is completed it will hold another execution address
								
								
		v)Native method area: The area where all the native methods are executed is known as Native method area
		
								Native method: the method which is declared using native keyword is known as native method
											  Note: native methods are the methods which are developed in other programming languages not in java
												
												
												
3) Execution engine: The byte code which is copied onto run data time areas is executed by execution engine.
					 The execution engine reads byte code and executes it by step by step.
					 The execution engine has two translators
					 
					 
					Interpreter: Interpreter reads the byte code fastly but executes slowly.
								 whenever we have interpreter while executing program we can accept the request in the middle of the program.
								 If we are calling a method multiple times and each time the interpreter is required
					
					JIT compiler: Just in time compiler and bulk of operations are executed by JIT compiler.
								  if method called multiple times then JIT compiler will use interpreter to reads the byte code and changes into native code,
								  and this native code will be called without  reading again when method called multiple times.
								  
								  intermediate code generator: produce the intermediate code.
								  code optimizer: responsible for optimizing interpreter code.
								  target code generator: responsible for generating machine code or native code.
								  profiler: can be used to identify whether the code called multiple time or not.
								  
								  
								  
JNI: Stands for java native interface, can be used while native methods.
	 And for executing native methods we have native method libraries.

Garbage collector: Collect the objects which are not referenced. can be used for clean-up process.


Packages: Package is the container which groups the related types(classes,interfaces,annotations and enumerations).
		  Package name is unique that means no two packages have the same name.
		  naming convention is com.<company-name>.<name>;
							ex: package com.charani.coreJavaExamples;
		
		Syntax: package <package-name>; // here the package is keyword to create the package
		
		1)pre-defined packages: The packages which are already defined in java are known as pre-defined packages.
								ex: java.lang -> language package and it is the default package
									java.util -> utility package provides the utility classes
									java.sql -> provides classes for jdbc transactions
									java.net -> provides the classes for networking applications.
									java.io -> provides the classes for input and output operations.
									
		
		2)user-defined packages: The packages which are defined by programmer are known as user-defined packages.
								 All the packages we create in our application comes under user-defined packages.
								 
								
Import : Importing/loading  user defined or predefined java classes into our current program is known as import
		 import can be done at the first line of our program.

		1)Implicit import: Load all classes from the package is known as implicit import
		
				Syntax: 
						import <package-name>.*; // here the * indicates all the classes from the package
		
		2)Explicit import: Load specific classes from package is known as explicit import.
						
						Syntax: 
								import <package-name>.<class-name>;
								
								
Java file: The file which is saved as a .java extension is known java file.
		   Within the java we can declare classes interfaces,methods enums.
		   the first statement in the java should be package declaration, then import statements.
		   after import statements we can declare the classes,methods,interfaces, enums.
		   and each java file can have only one public class and which is having main method.
		   java file should save a class name which is public.
		   
Naming conventions in java:
							
							Type 1: 
									declaring Classes and interfaces: while classes declaring classes and interfaces we should follow pascal case type.
										ex: class TestClassDeclaration{
															}
															
							Type 2: 
									Methods: While declaring methods we should follow camel case type.
									
											Ex: public void methodNameDeclaration{
												
											}
											
							Type 3:
									Variables: variable names should be meaningful.
									ex: String name = "akhil";
										String yuy = "akhil";// should give meaningful name  so avoid declaring such variable names 
									Variable names should not start with _ and $ even though they allowed
										ex: String _test= "test"; //avoid declaring such variable names 
											String $test = "test"; //avoid declaring such variable names 
									Variable name should not be declared with operators
										ex: String +test = "test"; // //avoid declaring such variable names 
									Variable name also should follow camel case type
									No two variables have the same name.unique names we should use.
									
							Type 4:
							
									Constant declaration: constants should be declared with all uppercase type.
										
											ex: final String ADHAAR_NUMBER = "1222432435";
											
							Type 5: 
								
									Package: The prefix of each unique package name should be lowercase and should be any of top level domain names like com,edu,org,gov etc.
											 Then we should follow same variable naming conventions.
											 ex: org.Osamina.Student.Info;
												 gov.Telangana.TSRTC;
											 
											
									
Note: The changes made in one object will not reflect on another object in terms of non-static.
	  But in terms of static the changes made in one object will reflect all objects created for the class.
	  
								  Ex: 
							public class StaticNonStatic {

								public static void main(String[] args) {
									
									StaticNonStaticTest obj = new StaticNonStaticTest(); // one object is created
									
									obj.k=70;
									obj.j=90;
									System.out.println(obj.k); // 70
									System.out.println(obj.j);  //90
									
									StaticNonStaticTest obj1 = new StaticNonStaticTest(); // second object is created
									System.out.println(obj1.k); // 30
									System.out.println(obj1.j);  //90
									
								}

							}

							class StaticNonStaticTest{
								
								int k = 30;
								static int j = 20;
								
							}
							
OOPs: Which stands for object oriented programming.
	  Java is the object oriented programming language. that means it use objects in programming. that means the primary source is object.
	  
	  1)class
	  2)interface
	  3)arrays
	  4)enums
	  
	  
	  
	  Access-Modifiers : Access-Modifiers are Can be used to reduce or increase the scope of the programming components(class,interface,variable,method etc.)
						 That means specify the availability of programming components. 
	
	 public : The members which are declared using public are can be accessed anywhere from project.
				Syntax : public <data type/return type> <variable-name/method-name/class-name>{
				
				}
				
	Private : The Members which are declared using private are can be accessed within the class only. to access these members we have to provide getter methods.
	
	Protected : The members which are declared using protected are can be accessed within the package. But in inheritance the child class can access protected members of parent class.
	
	default:  The members which are declared using protected are can be accessed within the package. this is the default modifier if we don't provide any one.
	  
		
	 1)class: class is the template or structural layout from which objects are created.
	 
			Syntax: 
						<access-modifier> class TestClass{
							
							// set of statements
							
						}
			Allowed access-modifiers for the class are public and private. but private classes are declared as inner class.
						
						Ex: 
								class Test{

									private class InnerClass{
		 
										 }
									}
						
			Class represents the set of properties or methods that are common to all the objects created for it.

								  
					
			Properties: Means variables or data.
			
						Variables: Variables are the data holders and can be used to perform some operation.
								
								Q: Why to declare variable?
								Ans: if some data is shared by multiple methods then declare variable and hold that data into that variable. so that all the methods can access
								
							Two types of variables we have in java.
								i)static: declared with static keyword and accessed directly by class name
								ii)non-static: declared without static keyword and accessed by object
											   non-static divided into two types.
											   i)instance: declared inside class outside method
											   ii)local: declared inside method
									
										
			Methods: The functions which are declared inside the class are known as methods.
					 Function: Which perform some task or do some operation known as function
					 Methods can be declared for reusability
					 
					 Syntax: <access-modifier> <return-type> <method-name>(Parameter list){
						 
					 }
					 method signature: from the above syntax return-type is not a part of method signature but every method should be declare with return-type.
									  
					 return-type: Can be used to specify what type of data the method can return after it's execution.
								  if we don't want to return the value after execution then declared that method as void. void means return nothing.
					 Note: methods can be declared only inside class. and we can any number of methods
					 
					 Parameter: Parameters are the data carriers which carry the data from one method(method frame) to another method(method frame).
					 
					 Parameter list: list of parameters that method can accept. while calling a method we should pass same type or it's child type of parameters to the method it accepts 
					 
					Methods in java are two types:
						
						i) Non-Static Methods.
						
						ii) Static Methods.
						
						i) Non-Static Methods: The methods which are declared without static keyword are known as non-static methods.
											   These non-static methods will get the memory within the heap area while object creation.
											   So that we can access non-static methods by creating object for the class.
											   
										Object: Object is a physical existence of a class.
												A smallest memory created as part of heap area, which holds non-static members of the class.
												Object can have states and behaviours of the class
												states: all the variables declared inside the class.
												behaviours: all the methods declared inside the class
												
												Syntax for creating object:
																			<class-name> <object-reference-name> = new <class-name>();
																			
																			new: new is the keyword to create the object for the class.
																			
																			ex: TestClass obj1 = new TestClass(); // object is created for TestClass and name of the object is obj1.
															
																		Note: object reference should follow the same variable naming conventions.
																		
												Q: Why to create object?
												Ans: To access non-static members of the class.
												
										
									
						ii) Static Methods: The methods which are declared with static keyword are known as static methods.
											These static methods will get the memory within the method area while class loading.
											Q: when the class will be loaded?
											Ans: When the components of the class are used.
											So that we can access static methods directly by class name.
										
											
						
										EX:
												public class MethodTypes {

														public static void main(String[] args) {
															Methods.printTableByStaticMethod();
															Methods methods = new Methods(); // creating object
															System.out.println(methods.hashCode());
															methods.printTableByNonStaticMethod();
															

														}

													}


													class Methods{
														
														int k = 90;
														static int j =89;
														public void printTableByNonStaticMethod() {
															Scanner sc = new Scanner(System.in);
															System.out.println("Enter number to print table from non-static method");
															int num = sc.nextInt();
															for(int i=1;i<=10;i++)
															{
																System.out.println(num+"*"+i+" = "+num*i);
															}
														}
														
														public static void printTableByStaticMethod() {
															Scanner sc = new Scanner(System.in);
															System.out.println("Enter number to print table from static method");
															int num = sc.nextInt();
															for(int i=1;i<=10;i++)
															{
																System.out.println(num+"*"+i+" = "+num*i);
															}
														}	
														
														
													}	
						Note: Static methods can access only static members of the class.
							  And non-static methods can access both static and non-static members of the class.
								
						
						Bases on the return-type the methods are categorised into two types.
											
											i) method with return type: if the method returns some value after it's execution known as method with return-type
																		Note: Returned value will come back to the method call and we should hold the value in separate variable of same or it's higher data type.
																		
													Method call: calling a method. methods will not be executed automatically we should call them.
											
											ii) method without return-type: if the method doesn't returns any value after it's execution known as method without return-type
																			if we don't want to return value after method execution then declared that method with void as a return type.
																			
								EX:
								
									public class MethodsBasedOnReturnTypes {

														public static void main(String[] args) {
															
															ReturnTypeMethods obj = new ReturnTypeMethods(); // object created
															obj.methodWithoutReturnType();
															int num = obj.getNumberToPrintTable();
															for(int i=1;i<=10;i++)
															{
																System.out.println(num+"*"+i+" = "+num*i);
															}
														}

													}

													class ReturnTypeMethods{
														
														
														public int getNumberToPrintTable() {
															
															Scanner sc = new Scanner(System.in);
															System.out.println("Enetr number to print tables: ");
															int num = sc.nextInt();
															return num;
															
														}
														
														public void methodWithoutReturnType() {
															Scanner sc = new Scanner(System.in);
															System.out.println("Enetr number to print tables from methodWithoutReturnType: ");
															int num = sc.nextInt();
															for(int i=1;i<=10;i++)
															{
																System.out.println(num+"*"+i+" = "+num*i);
															}
														}
													}

						Bases on the parameters the methods are categorised into two types.
											i) Method with parameter: Declaring a method with parameter list is known as Method with parameter
																	  While parametrized method call we should pass the parameters to the method with same or it's child type of data
											ii) method without parameter: Declaring a method without parameter list is known as Method without parameter
											
											
						Varargs: variable args that means passing variable number of arguments.
								 varargs is same as the passing array of parameters to method.
								 Varargs should be declared as a last argument in method signature and can only be one varargs in method signature
						
						Syntax: 
						
									<access-modifier> <return-type> <method-name>(<data-type> ...<variable-name>){
										
									}
									
									EX:
											public void printTable(int lentgh,int ...numbers) {
												for(int num : numbers) {
													for(int i=1;i<=lentgh;i++)
													{
														System.out.println(num+"*"+i+" = "+num*i);
													}
												}
												
											}
											
									...numbers here three dots tells the compiler that varargs is used and these values should be store in array refereed by numbers.
									
		Note: While compilation compiler will look for method signature and if two methods having same method signature then compiler will through exception. 
			  method signature: access-modifiers, method-name and parameter list comes as part of method signature.
			  So while declaring methods we should differentiate them at least by parameter types or number of parameters.
			  
			  
			  user defined methods: methods defined by user or programmer.
			  
			  predefined methods: methods are already defined in java.
									 ex:
											Scanner sc = new Scanner(System.in);
											sc.nextInt();// nextInt() is predefined method to read int type of data from user
											
											
											
									EX:
										public class MethodsBasedOnParameter {

												public static void main(String[] args) {

													MethodsTypes obj = new MethodsTypes();
													short num = 12;
													obj.printTable(num, 20);
													obj.printTable();
													obj.printTable(10, new int[] { 17, 19 });
													obj.printTableVargs(10, 17,19);

												}

											}

											class MethodsTypes {

												public void printTable(int num, int lentgh) {
													for (int i = 1; i <= lentgh; i++) {
														System.out.println(num + "*" + i + " = " + num * i);
													}
												}

												public void printTable() {
													Scanner sc = new Scanner(System.in);
													System.out.println("Enetr number to print tables from methodWithout parameters: ");
													int num = sc.nextInt();
													for (int i = 1; i <= 10; i++) {
														System.out.println(num + "*" + i + " = " + num * i);
													}
												}

												public void printTableVargs(int lentgh, int... numbers) {
													for (int num : numbers) {
														for (int i = 1; i <= lentgh; i++) {
															System.out.println(num + "*" + i + " = " + num * i);
														}
													}

												}

												public void printTable(int lentgh, int[] numbers) {
													for (int num : numbers) {
														for (int i = 1; i <= lentgh; i++) {
															System.out.println(num + "*" + i + " = " + num * i);
														}
													}

												}
											}
											
			  Coding Rules for method with parameters and method with return type:
					
					i)The data type of parameters used in method call must be equal or it's lower type to the parameters declared in method signature.
					ii) The return type of the method must be equal to the type of the method returns.
					iii) The data type of the variable which holds the returned value while method call must be equal to data type of the method returns or it's higher type.
					
					
brackets: 	
			[]: square brackets --> to declare array
			{}: curly brackets --> to declare blocks or class or methods
			(): round brackets or parentheses --> to be used in method signature to accept parameters
			<>: angle brackets --  used as operators in java
					
Blocks: A block is a set of statements written inside curly brackets.
		The blocks will be executed automatically that means blocks calling is not there, where as methods will not be executed automatically,that means we should call them.
		The blocks are having higher priority than methods
		the variables declared inside the blocks are local to that block only, so outside the block we can't access.

		1) static block: The block which is declared using static keywords known as static block.
						 The static block will be executed only once while class loading.
						 The static block can be used to initialize static variables
						 The static block will be executed before main method. even though execution start from main method
						 If we have multiple static blocks then all blocks will be executed as top-down way
						 Within the static block we can access only static variables
						 If we load the class multiple times but static block will be executed only once
		
		2) instance or non-static block: The block which is declared without static keyword known as instance of non-static block.
										 The instance block will be executed automatically while object creation(ex: TestClass obj = new TestClass();).
										 The instance block can be used to initialize instance variables
										 If we have multiple non-static blocks then all blocks will be executed as top-down way
										 Within the non-static block we can access both static and instance variables
										 instance block will be executed for all the objects created for the class.(ex: if we create 10 objects then instance block will be executed 10 times)
										 
Variables: 
			static variables: declared with static keyword and inside class and outside the method.
			instance variables: declared without static keyword and inside class and outside the method.
			local variables:  declared inside method without static keyword because static keyword is not allowed inside method.
			
			
Note : The changes made by one object with respect to instance variable, will be reflect to only the same object.
	   The changes made by one object with respect to static variable, will be reflect to all the objects created for the class.
	   
	   
				Ex for blocks:
				
														public class BlocksExample {
																	
																	static int number;
																	
																	static{
																		System.out.println("Executed from first static block");
																		number = 23;
																	}
																	static{
																		System.out.println("Executed from second static block");
																		number = 63;
																	}
																	
																	public static void main(String[] args) {
																		System.out.println("Executed from main method");
																		System.out.println("Value of number: "+number);
																		System.out.println(BlocksEx.j);
																		System.out.println(BlocksEx.j);
																		BlocksEx obj = new BlocksEx();
																		obj.k = 67;
																		obj.j  = 90;
																		BlocksEx obj1 = new BlocksEx();
																		BlocksEx obj2 = new BlocksEx();
																		System.out.println(obj2.k);
																		System.out.println(obj2.j);
																	}

																}

																class BlocksEx{
																	
																	int k;
																	static int j;
																	static {
																		int h =89; // local to this block only.
																		j =23;
																		//k=78; // we can't access as it is a intance variable
																		System.out.println("Executed from static block of BlocksEx: ");
																	}
																	
																	{
																		//System.out.println(h);
																		k=45;
																		j= 89;
																		System.out.println("Executed from instance block of BlocksEx: ");
																		
																	}
																	
																	
																}
																

static keyword in java: static keyword in java mainly used for memory management
						Used to share the same variable or method of given class.
						we can use static keyword to declare variables,methods,blocks and nested/ inner classes(declare class inside class is known as inner class.)
						if we declare any member as a static that can be common to all objects created for the class and if we change the value by any of object then the changes reflected to all objects.
						
			
			
Constructor: Constructor is a special type of method which is declared with the same class name. or A method which is declared with same class name and without return type known as constructor.
			 And If we declare the constructor with return-type then it is treated as a method.
			 Constructor can be used to initialize objects. and it is called when the instance/object of the class is created.(Ex: TestClass obj = new TestClass();)
			 At the time of constructor calling the memory of the object is allocated in the heap area.
			 Every time an object is created with the new keyword at least one constructor is called.
			 A constructor will return current class object.
				
			 
			 EX:
					public class TestConstructor{
						
						TestConstructor(){
							
						}
						public static void main(String ar[]){
							
						}
						
						
					}
			 
		Note: it is not necessary to create constructor for a class, because the java compiler will create the default constructor if not created by the programmer
		
		
		Difference between constructor and method:
		
													i) Constructor must have the same name as class name, but for methods we can use any name.
													ii) Constructor do not return any value where as methods can return
													iii) Constructor can be called only once while object creation but we can call methods any number of times.
													
													
													
			1) Default Constructor: The constructor which is generated by the compiler is known as default constructor.and it is zero/ no-arguments constructor
			
			
			2) User-defined Constructor: The constructor which is written by the programmer is known as user-defined constructor.
									
										i) Constructor with parameter: The constructor which can accept the parameters is known as constructor with parameter.
																	   The parameters can be passed to constructor at the time of object creation.(ex: TestClass obj = new TestClass(12);)
										
										ii) Constructor without parameter(also known as default constructor): The constructor which is declared by the programmer and doesn't accept any parameters
										
				Note: The default constructor is defined by complier only when there is no constructor created for the class by the programmer.
				
				
			Note: private constructor can be used to restrict outsider to create object for the class. to access object we should provide the method which returns object for the class.
			
			
			
			
			Ex1: 
			

											public class ConstructorExample {

												ConstructorExample() {
													System.out.println("Zero-arguments constructor");
												}

												ConstructorExample(int i) {
													System.out.println("arguments constructor:" + i);
												}

												ConstructorExample(String name, int age) {
													System.out.println("arguments constructor:\n" + "Name: " + name + ", Age: " + age);
												}

												public static void main(String[] args) {

													ConstructorExample constructorExample = new ConstructorExample(); // Zero-arguments constructor
													ConstructorExample constructorExample1 = new ConstructorExample(12); // arguments constructor
													ConstructorExample constructorExample2s = new ConstructorExample("TestName", 18); // arguments constructor

												}

											}
											
			Ex2:


							public class PrivateConstrutor {

								public static void main(String[] args) {
									
									//ConstructorPrivate obj = new ConstructorPrivate();// gives error due to private constructor.
									ConstructorPrivate instance = ConstructorPrivate.getInstance();
									instance.k=78;
									System.out.println(instance.k);
									ConstructorPrivate instance1 = ConstructorPrivate.getInstance();
									ConstructorPrivate instance2 = ConstructorPrivate.getInstance();
									System.out.println(instance1.k);
									System.out.println(instance2.k);
								}

							}

							class ConstructorPrivate{
								int k =90;
								static ConstructorPrivate instance = null;
								
								private ConstructorPrivate(){
									
								}
								
								
								public static ConstructorPrivate getInstance() {
									if(instance == null) {
										instance =  new ConstructorPrivate();
									}
									
									return instance;
								}
								
							}



Initialize values to variables: 		
								i) At the time of declaration.
								
								ii) using blocks.
								
								iii) using constructor.
								
"this" keyword in java: this is the reference variable which refer current class object.

						1) use this keyword to access instance members of the class.
						
								
							public class ThisKeywordExample {

									public static void main(String[] args) {
									System.out.println("Execution started.!");
									This obj = new This();// zero-argument constructor
									This obj1 = new This(12,34);
									obj.displayInstanceVariable();
									obj1.displayInstanceVariable();

									}

								}


								class This{
									
									int k;
									int j;
									This(){
										
									}
									This(int k , int j){
										this.k = k;
										this.j = j;
									}
									
									
									
									public void displayInstanceVariable() {
										System.out.println("Value of k : "+k);
										System.out.println("Value of j : "+j);
									}
								}
													
													
						2) use this keyword to access current class constructor: 
																				Note: The constructor call must be the first statement within the constructor.
																				
																		Ex:
																		
									public class ThisKeywordForCurrentClassConstructor {

											public static void main(String[] args) {
												System.out.println("Execution started.!");
												
												ThisConstructor obj = new ThisConstructor();
												obj.displayInstanceVariable();
											}

										}


										class ThisConstructor{
											
											int k;
											int j;
											String str;
											
											/* default constructor or zero-arguments constructor*/
											ThisConstructor(){
												this(12,34);
											}
											
											
											ThisConstructor(int k, int j) {
												this(56,78,"Java");
												/*
												 * this.k = k; this.j = j;
												 */
														
											}
											
											ThisConstructor(int k, int j,String str) {

												this.k = k;
												this.j = j;
												this.str = str;

											}
											
											public void displayInstanceVariable() {
												System.out.println("Value of k : "+k);
												System.out.println("Value of j : "+j);
												System.out.println("Value of str : "+str);
											}
											
											
										}
													
						3)use this keyword to call current class instance method:
						
								 Note: For calling current class methods this keyword is not needed why because the compiler will automatically add this keyword.
									   But to dedifferentiate we need to use. 
						
									EX:
									
										public class ThisKeywordToCallInstanceMethod {

											public static void main(String[] args) {
												
												CallIntsanceMethod obj = new CallIntsanceMethod();
												obj.callInstanceMethod();

											}

										}

										class Test{
											
										public void instanceMethod() {
												
										System.out.println("From Test class");
										}

										}

										class CallIntsanceMethod extends Test{
											
											
											public void callInstanceMethod() {
												
												this.instanceMethod();
												super.instanceMethod();
											}
											
											public void instanceMethod() {
												System.out.println("From CallIntsanceMethod class");
											}
											
										}
										
						4) use this keyword as a method argument: 
						
								Ex: 	
								
											public class ThisKeywordAsMethodArgument {

													public static void main(String[] args) {
														
														Class2 class2 = new Class2();
														class2.display();
													}

												}


												class Class1{
													
													public void display(Class2 class2) {
														
														System.out.println("Display from class1");
													}
												}

												class Class2{
													
													Class1 obj = new Class1();
													
													public void display() {
														obj.display(this);
													}
													
													
												}
						
						5) use this keyword as a constructor argument: 
						
						
									Ex:
									
										public class ThisKeywordAsConstructorArgument {

													public static void main(String[] args) {
														
														TestClass1 testClass1 = new TestClass1();
													}

												}


												class TestClass1{
													
													TestClass1(){
														
														TestClass2 testClass2 = new TestClass2(this);
													}
													
													public void display() {
														
														System.out.println("Executed from TestClass1");
													}
												}


												class TestClass2{
													
													TestClass1 testClass1;
													
													TestClass2(){
														
													}
													
													TestClass2(TestClass1 testClass1){
														this.testClass1 = testClass1;
														testClass1.display();
													}
													
												}
						
			 
			 
			 
Inheritance: The process of extending/inheriting/getting features from one class to another is known is inheritance.
			 here the features can be methods,constructor and variables
			 
			 Parent class: The class whose features are extended/inherited is known as parent class or super-class
			 
			 child class:  The class which inherits/ extends features from another class is known child class or sub-class.
			 
			 This inheritance can be achieved using extends keyword
			 
			 Syntax: 
			 
						class <class-name/child-class> extends <class-name/parent-class>{
							// block of statements
							
						}
						
			super keyword: super is the reference variable which can be used to access parent class features.
						   use super keyword to access parent class constructor but this access should be inside the constructor of the child class and should be the first statement
							
							
					EX:
					
								public class InheritanceExample {

										public static void main(String[] args) {
										
											class2 class2 = new class2();
											class2.getBalance();
										}

									}

									class class1{
										
										String accNumber = "14324324455";
										public void displayAccountInfo() {
											
											System.out.println("Account holder name is java");
											
										}
										
										class1(){
											System.out.println("class1 constructor");
										}
										
									}

									class class2 extends class1{
										
										class2(){
											super();
										}
										
										String accNumber = "465465466";
										public void getBalance() {
											
											super.displayAccountInfo();
											System.out.println("balance of account: "+super.accNumber + " is Rs"+800);
										}
										
										public void displayAccountInfo() {

											System.out.println("Account holder name is core");

										}
										
									}
									
									
							
						Advantages:
										1) code reusability : A child class can use the same features from parent class.
										2) Abstraction : A child class can access parent class features but the implementation is not visible to child class.
										3) polymorphism :  Object in multiple forms 
										
										
						Disadvantage : tight coupling with parent class. Means the changes made in parent class will reflect on child classes.
									   if a class extending features from more than one class than it's not easy to understand from which the features are extended.
									   
									   
					Types of inheritance:
					
									1) Single inheritance: Extending features from one class is known as Single inheritance
									
											Ex:
												public class SingleInheritance {

													public static void main(String[] args) {
														Two two = new Two();
														two.display();
													}
												}

												class One {
													
													public void display() {
														System.out.println("From class One and display method");
													}
													
												}

												class Two extends One{
													
													
												}
									
									2) multilevel inheritance: In this one class extends features from parent class and that class acts as parent class for another class.
											
											EX:
											
										public class MultiLevelInheritance {

												public static void main(String[] args) {
													
													Test4 test4 =  new Test4();
													test4.extendFromTest1();
												}

											}


											class Test1{
												
												public void extendFromTest1() {
													System.out.println("Multilevel inheritance");
												}
											}

											class Test2 extends Test1{
												
												
												
											}

											class Test3 extends Test2{
												
												
											}

											class Test4 extends Test3{
												
												
											}
																				
									
										
									
									3) Hierarchical inheritance :  One class acts as base class or parent class more than one class.
									
											EX:
											
													public class HierarchicalInheritance {

															public static void main(String[] args) {

																SBI sbi = new SBI();
																sbi.displayPolicy();
																HDFC hdfc =  new HDFC();
																hdfc.displayPolicy();
																ICICI icici = new ICICI();
																icici.displayPolicy();
																
															}

														}


														class RBI{
															
															public String getCommonPolicy() {
																return "Every account holder should link PAN with account";
															}
														}

														class SBI extends RBI{
															
															public void displayPolicy() {
																System.out.println("Policy for SBI: "+getCommonPolicy());
															}
															
															
														}

														class HDFC extends RBI{
															public void displayPolicy() {
																System.out.println("Policy for HDFC: "+getCommonPolicy());
															}
														}

														class ICICI extends RBI{
															public void displayPolicy() {
																System.out.println("Policy for ICICI: "+getCommonPolicy());
															}
															
														}
									
									4) Multiple inheritance: Extending features from more than one parent class into one child class is known as Multiple inheritance
															 But in java multiple inheritance is not supported using classes due to ambiguity(conflict of from which parent class the features)
															 But in java multiple inheritance is supported using interfaces.
															 
															 
												
									
									5) Hybrid inheritance: circular inheritance also supported using interfaces.
									
									
						Note: We can extend only one class at a time.
							  for calling parent class constructor use super keyword and this can be the first statement inside child class constructors
							  While inheriting features from parent the child class can't access private members of parent class.
							  
			Method hiding: if parent class having static method and child class also having same static method with same method signature then it is known as method hiding.
				   But in case of instance methods same can be called as method overriding.
				   This is because static methods are binded to class where as instance methods are binded to object.
				   Static methods overdried but it's not override it's method hiding.
				   
				   EX:
									public class MethodHiding {

										public static void main(String[] args) {
											ChildClass obj = new ChildClass();
											ChildClass.display();
											obj.instanceMethod();
										}

									}

									class ParentClass {

										static public void display() {
											System.out.println("From parent class static method");
										}

										public void instanceMethod() {
											System.out.println("From parent class instance method");
										}

									}

									class ChildClass extends ParentClass {

										static public void display() {
											System.out.println("From child class static method");
										}

										public void instanceMethod() {
											System.out.println("From child class instance method");
										}
									}
							  
							  
Polymorphism: Means having many forms

			1) static/compile-time polymorphism: method resolution done at compile-time and we can achieve using method overloading.
			
												Method overloading: The process of declaring methods with same name with different parameters is known method overloading
																	Same method signature but parameter list is different.
																	it can be done in same class.
																	two methods should be different by at least parameter type or length of the parameters that the method can accept.
																	
														EX:
														
																public class MethodOverLoading {
																		public static void main(String[] args) {
																				
																			Scanner input = new Scanner(System.in);
																			
																			System.out.println("Enter number");
																			int num = input.nextInt();
																			OverloadedMethods obj = new OverloadedMethods();
																			obj.printTable(num);
																			System.out.println("Enter number to print table based on length:");
																			int num1 = input.nextInt();
																			System.out.println("Enter length:");
																			int length = input.nextInt();
																			obj.printTable(num1, length);
																			System.out.println("Enter number to print table based on length and message:");
																			int num2 = input.nextInt();
																			System.out.println("Enter length:");
																			byte length1 = input.nextByte();
																			System.out.println("Enter mssage to display:");
																			String message = input.next();
																			obj.printTable(num2, length1, message);
																		}
																	}


																	class OverloadedMethods{
																		
																		
																		public void printTable(int num) {
																			for(int i =1; i<=10;i++) {
																				System.out.println(num+" X "+i + " = "+num*i);
																			}
																		}

																		public void printTable(int num, int length) {
																			for(int i =1; i<=length;i++) {
																				System.out.println(num+" X "+i + " = "+num*i);
																			}
																		}
																		
																		public void printTable(int num, byte length) {
																			for(int i =1; i<=length;i++) {
																				System.out.println(num+" X "+i + " = "+num*i);
																			}
																		}
																		
																		public void printTable(int num, byte length,String message) {
																			System.out.println("Message from user:" + message);
																			for(int i =1; i<=length;i++) {
																				System.out.println(num+" X "+i + " = "+num*i);
																			}
																		}
																	}
																				
					
			
			2) dynamic/runtime polymorphism: Also known as dynamic method dispatch. methods resolved at runtime instead of compile-time.
											 Declare methods with same method signature is known method overriding.
											 method overriding can be done from parent class to child class.
											 If the method parent class method doesn't fullfill the requirement of child class then override that method in child class.
											 While overriding if parent class method is not overrided by child class then the parent class method will be executed otherwise child class method is called(executed).
											 While overriding we can't reduce the scope of the parent class method
											 The child class can access protected members of the parent class even though the scope of protected members is within the package.
											 The parent class reference can hold child class object but using parent class reference we can access only parent class variables.
											 
											 
					EX:
					
												public class MethodOverriding {

														public static void main(String[] args) {
															Parent parent = new Parent();
															parent.printTable(23);
															Child child = new Child();
															child.printTable(12);
															Parent parent1 = new Child();
															//System.out.println(parent1.k);// parent class reference can access only parent class variables.
															parent1.display();
														
														}

													}


													class Parent extends ProtectedMembers{
														
														int j =89;
														
														protected void printTable(int num) {
															System.out.println(protectedMessage);
															// System.out.println(defaultMessage); can't be accessed as the variable is default one
															for(int i =1; i<=10;i++) {
																System.out.println(num+" X "+i + " = "+num*i);
															}
														}
														
														public void display() {
															System.out.println("I'm from parent class..!");
															
														}
														
													}

													class Child extends Parent{
														
														int k =90;
														
														public void printTable(int num) {
															System.out.println("Enter length: ");
															Scanner sc = new Scanner(System.in);
															int lenth = sc.nextInt();
															for(int i =1; i<=lenth;i++) {
																System.out.println(num+" X "+i + " = "+num*i);
															}
														}
														
														public void display() {
															System.out.println("I'm from child class..!");
															
														}
													}

											 
			
						Note: protected members(members which are declared using protected keyword) can accessed out side of the package by child class.

Encapsulation: The process of binding the data(variables) together it's methods(functions) is known as encapsulation.
			   We can achieve encapsulation using private members. that means if we declare any member as a private then outside the class we can't access.
			   
			   EX:
			   
								public class EncapsulationExample {

										public static void main(String[] args) {
											
											Encapsulation obj = new Encapsulation();
											obj.display();
											//System.out.println(obj.j);
											//System.out.println(obj.k);
										}

									}

									class Encapsulation{
										
										/*data or variables*/
										 private int k = 90;
										 private int j = 78;
										
										public void display() {
											System.out.println("The value of k: "+ k);
											System.out.println("The value of j: "+ j);
										}
										
									}
									
									
Abstraction: The process of hiding implementation and providing only the functionality to the user is known as abstraction.

			In java abstraction can be achieved using interfaces and abstract classes.
			
		Interface: An interface is a collection of abstract methods.
		
		Note: In java based on implementation there are two types of methods.
		
					1) Concrete methods: The method which is declared and also defined(writing/having method body).Concrete methods are not ended with semicolon(;)
					
					syntax: 
								<access-modifier> <return-type> <method-name>(zero/more parameters){
									// set of statements
									
								}
					
					2) abstract method:  The method which is declared but not defined(no method body). and abstract methods are ended with semicolon (;).
										 Implementation of abstract methods can be done in implementation classes of interface
					
							Syntax:
										<access-modifier> <return-type> <method-name>(zero/more parameters);
										
					We can't create object for interface, because it's an abstract component. we can create object for implementation class and access interface members
					An interface reference can hold object of implementation class.
					Within the interface all variables are by default public static and final.
					Within the interface all the methods are by default public and abstract.
					We can implement interface using implements keyword
					We can declare interface using interface keyword.
					Within the interface all variables must be assigned some value.
					
					syntax for interface:
					
											interface <interface-name>{
												//abstract methods.
												// variables.
												
											}
					
							
							
							Ex:
							
										interface I1{
											public void display();
											
										}
										
										class Impl1 implements I1{
											
											@override
											public void display(){
												System.out.println("From IMPL1");
											}
										}
			
									
					final keyword: final keyword can be used to declare constants.
								   We can use final keyword only with variables,methods and classes
								   the variables which are declared using final keyword are final variables and can't be reassigned.
								   The methods which are declared using final keyword are final methods and can't be overrided.
								   The classes which are declared using final keyword final classes and can't be inherited/extended.
								   
								   
								EX:
											public class FinalExample {

													public static void main(String[] args) {
													
														Final1 obj = new Final1();
														obj.display();
														Final obj1 = new Final();
														System.out.println(obj1.str);
													}

												}

												 final class Final{
													String str = "Java";
												}


												/* class Final1 extends Final{ */ // gives error as Final is the final class
												class Final1 {
													final int k = 30;
													public void display() {
														// k = 67; // re-assign and can't be done decause it's a final
														
														System.out.println("value of k: "+(k)+30); // here changing value
														
													}
													
													final public void finalMethod() {
														System.out.println("From final method");
													}
													
												}


												class Final2 extends Final1{
													/* 
													public void finalMethod() {
														System.out.println("From final method");
													}
													can't override final method
													*/
												}
										
							Initialization of final variables:
																There are three ways to initialize value for final variables.
																When a variable is declared as final and value is not assigned then it known as blank final variable.
																
																i) At the time of declaration: Assign value to the final variable at the time of declaration
																							   Ex : final int j =90;
																ii) Using instance block: Use instance block to initialize values to final instance  variables.
																iii) Using static block: Use static block to initialize value to static final variables
																iv) within the constructor: Use constructor to initialize values for final instance variables.			
																							If the class has multiple constructors and the variables which are initialized in one constructor must be initialized in all of constructors.
																
																
																Note: The static variables which are declared using final keyword can be initialized at the time of declaration or within the static block.
																		  we can't initialize within the instance block or constructor But,
																		  The static variables which are declared without final keyword are can also be initialized within the instance block or constructor
																		  
																Note: The final variables which are declared inside constructor or methods or blocks are local to that area only, and must be initialized at the time of declaration.
																
									EX:
									
													public class FinalVariableInitialization {

															final String str;
															final static String str1;
															final int k;

															{
																final int j;
																j = 34;
																//j = 34;
																str = "Java";
																// str1 = "initialzie from instance block";
															}

															static {
																// str = "static initialize";// instance variables can't be accessed in static
																// area
																final int j;
																j = 34;
																str1 = "initialzie from instance block";
															}

															FinalVariableInitialization() {
																final int j;
																j = 34;
																this.k = 89;
															}
															
															FinalVariableInitialization(int val){
																this.k = val;
															}
															
															FinalVariableInitialization(String val){
																this.k = 67;
															}

															public static void main(String[] args) {
																final int j;
																j = 34;
																
																FinalVariableInitialization obj = new FinalVariableInitialization();
																FinalVariableInitialization obj1 = new FinalVariableInitialization(12);
																System.out.println("Value of str : "+obj.str);
																System.out.println("Value of str1 : "+str1);
																System.out.println("Value of K : "+obj.k);
																System.out.println("Value of K from another constructor: "+obj1.k);
															}

														}
														
			
			
			*) In interface we can declare only abstract methods till java7 but from java8 onwards we can also declare default and static concrete methods.
			*) default concrete methods can be accessed using object of the implementation class.
			   if any method need not to be implemented by any of it's implementation classes then declare that method as a default method.
			*) static concrete method can be accessed directly from interface name.
			   if all of implementation classes uses some common information/logic then declare a static concrete method and write that logic inside static concrete method.
			
				
				
			Note : If any class implements any interface then that class must be override all the abstract methods declared inside interface.
				   To achieve multiple inheritance by using interfaces, if multiple interfaces having same methods but the implementation is separated by implementation class. that's why there is no ambiguity.
				   using interfaces we can achieve 100% abstraction. here we are completely hiding implementation of methods.
				   A class can't implement two interfaces if the classes having same method name but return-type is different.
				   
			Summary:
						*) The class which implements the interface needs to provide implementation for the methods declared inside interface.
						*) All the methods declared inside interface are by-default public and abstract.
						*) All the variables declared inside interface are by-default public static and final, and must assign some value.
						*) An interface can extend multiple interfaces but the class can extend only one class at a time.
						*) Use extends keyword to extend interface to interface and class to class.
						*) Use implements keyword to implement interface.
						*) declaring interface inside interface is known as inner/ nested interface and for this interface implementation should be provided by inner class of implementation class.
						*) An interface reference can hold object of implementation class.
						*) An interface can't implements interface it can only extends.
						*) From java8 we can declare default or static concrete methods inside interface.based on need the implementation class can override default method.
						   and static concrete methods will share common logic to all of it's implementation classes.
				   
				   
Abstract class: A class which is declared using abstract keyword is known as abstract class.
				It can have zero or more abstract methods.
				It can have concrete methods.
				We can't create object for abstract class,because it's an abstract.
				We can create constructor for the abstract class, and this constructor will be executed while creating object of it's child class.
				We can create blocks inside abstract class.
				We can have reference of another object inside abstract class.
				We can create final methods inside abstract class, but we can't use abstract keyword alongwith final keyword(final with abstract is not allowed).
				If a child class unable to provide the implementation for all of it's abstract methods then declare that child class as a abstract class, 
				And give chance to another child classes to provide implementation for rest of the abstract methods.
				We can declare static methods inside abstract class.
				inside interface all the methods are by-default abstract but inside abstract we need use abstract keyword for declaring abstract methods.
				We have to create object for it's child class and access the featurs of abstract class.
				An abstract class reference can hold object of it's child class.
				
				
				
Class:															Interface:														Abstract class:
======  														=============													================

1. Can have concrete methods									1. can have abstract, default and static concrete methods		1. Can have abstract and concrete methods.
2. Can have final methods,final with abstract is not allowed	2. can't declare final methods as abstract methods   			2. can have final methods but final with abstract is not allowed
3. can have constructors										3. we can't create constructors									3. we can create constructors				
4. can have blocks												4. we can't create blocks										4. we can create blocks
5. we can't create abstract methods								5. by-default all the methods are abstract						5. we can create abstract methods
6. Can have reference of another object							6. Can have reference of another object							6. Can have reference of another object
7. Can have object of another class								7. Can have object of another class								7. Can have object of another class
8. declared without abstract keyword							8. declared with interface keyword								8. declared with abstract keyword
9. can have final and non-final variables						9. by default final 											9. can have both final and non-final
10. can have static and non-static variables					10. by-default static											10. can have static and non-static variables
11. can be extended using extends keyword						11. can be implemented using implements keyword					11. can be extended using extends keyword.
12. Can extend only one class at a time							12. can implements/extends multiple interfaces at a time.		12. can extend only one class at a time.
13. We can create object										13. We can't create object										13. Can't create object
14. can be final class											14. we can't final interfaces									14. We can't create final abstract class.


Note: if any class has at least one abstract methods then that class should be declared as abstract class.
	  An abstract class can implements interface
	  
	  
generalization: The process of constructing super class/ parent class by taking common features from it's child classes is known as generalization.
				In this process one object will be created and that object can have all the features of parent class and overriding features of child class.
	 
		Ex:
								public class MainClass {

										public static void main(String[] args) {


											BaseClass obj = new SubClass();// generalization
											obj.display("Test");
											obj.display1();
										}

									}


									class BaseClass{
										public void display(String str) {
											System.out.println("Display from base class: "+ str);
										}
										
										public void display1() {
											System.out.println("display1 from base class");
										}
										
									}

									class SubClass extends BaseClass{
										public void display(String str) {
											System.out.println("Display from sub class: "+ str);
										}
										
										
									}
									
									
Type casting/ type conversion:	 The process of converting one type of data to another type of data.


								1. Automatic or widening conversion: This is done by complier automatically when two data types are compatible
																	 This can be done When we assign some value of smaller data type to bigger data type.
																	 
																	 boolean -> byte-> char-> short -> int -> long -> float -> double 
								
								2. Narrowing or explicit conversion: the process of converting bigger type of data to smaller type of data.
																	 And it's done automatically we have to do it manually.
 
																	double -> float -> long - > int -> short -> byte.
	  
	  
							Ex:
											public class MainClass {

														public static void main(String[] args) {
															
															
															int k = 14;
															long l = k; // implicit conversion
															byte b = (byte) l; // explicit conversion
															
															/*
															 * boolean bool = false; int j = (int)bool;
															 */
															
															char c = 'A';
															int h = (int)c;
															System.out.println(b);
															
															Parent parent = new Child(); // implicit conversion
															Child child  =  (Child)new Parent(); // explicit conversion
															
														}

													}

													class Parent{
														
													}


													class Child extends Parent{
														
													}
													
													
Inner class: The class which is declared inside the class is known as inner class.

		1) Member inner class: The class which is declared as a part of class i.e inside class outside of methods.
								i) non-static inner class:
															*) The inner class which is declared without static keyword is known as non-static inner class.
															*) The non-static inner class can access all the members of outer class.
															*) Within the non-static inner class we can declare non-static and static members(variables, methods etc.)
															*) Whenever we want to access inner class members then declare that inner class object inside the out class and access them using inner class object.
															*) outer class object will be created inside the main class.
															
								
								ii) static inner class: 
															*) The inner class which is declared using static keyword is known as static inner class.
															*) The static inner class can access only static members of outer class.
															*) Within the static inner class non-static and static members
															*) Whenever we want to access inner class members then declare that inner class object inside the out class and access them using inner class object.
															*) outer class object will be created inside the main class.
															
															
															
													EX:
																public class MemberInnerClass {

																		public static void main(String[] args) {
																			InnerClass obj = new InnerClass();
																			obj.obj.display1();
																			obj.obj1.display1();
																		}

																	}


																	class InnerClass{
																		
																		int k =90;
																		static int j = 89;
																		 
																		public void dis() {
																			System.out.println("Display from outer class non-static method");
																		}
																		
																		static public void dis1() {
																			System.out.println("Display from outer class static method");
																		}
																		
																		class InnerNonStatic{
																			
																			int g =90;
																			static int d = 78;
																			public void display1() {
																				dis();
																				dis1();
																			}
																			
																		}
																		
																		
																		static class InnerStatic{
																			int d = 90;
																			static int f = 78;
																			
																			public void display1() {
																				dis1();
																			}
																			
																		}
																		InnerNonStatic obj = new InnerNonStatic();
																		InnerStatic obj1 = new InnerStatic();
																		
																	}
																	
								Q: Why inner class access the members of outer class directly.?
								A: While object creation the reference of outer class object is binded to the object of inner class automatically by the JVM.
		
		
		2) Local inner class:  The class which is declared inside the method is known as local inner class.
							   We can declare only non-static local inner class. we can't declare local static inner class why because static keyword is not allowed inside the methods.
							   Object creation and access of all the members of local inner class can be done inside the method of outer class.
							   
							   
							   EX:
										
										
												public class MainClass {

														public static void main(String[] args) {
															OuterClass obj = new OuterClass();
															obj.outClassMethod();
														}
													}


													class OuterClass{
														
														
														public void outClassMethod() {
															
															class localInnerClass{
																
																int k = 90;
																
																public void display() {
																	System.out.println("Display from local inner class method");
																}
															}
															localInnerClass obj = new localInnerClass();
															obj.display();
														}

													}
		
									
		3) Anonymous inner class: The inner class which is declared without name is known as anonymous inner class.
		
						
							1) anonymous inner class as a class extension: Declare child class without name is known as anonymous inner class as a class extension
							
							
							
							2) anonymous inner class as a implementation class: Provide implementation class without name is known as anonymous inner class as a implementation class
							
							3) anonymous inner class as a method argument: declare inner class as a method argument.
							
							
							EX:
									public class AnonymousInnerClass {

												public static void main(String[] args) {
													Parent parent = new Parent() {
														public void display() {
															System.out.println("From child class method");
														}

														public void m1() {
															System.out.println("From method m1");
														}
													};
													parent.display();
													// parent.m1(); // error we can't access

													I1 i1 = new I1() {

														@Override
														public void sum(int k, int j) {
															System.out.println("Sum of variables: " + (k + j));

														}

													};
													i1.sum(12, 45);
													AnonymousInnerClass obj = new AnonymousInnerClass();
													obj.m2(new I2() {
														@Override
														public void sum(int k, int j) {
															System.out.println("From anonymous inner class as method argument:" + (k + j));
														}
													});

												}

												public void m2(I2 i2) {
													i2.sum(34, 29);
												}

											}

											class Parent {

												int k = 90;

												public void display() {
													System.out.println("From parent class method");
												}
											}

											interface I1 {

												public void sum(int k, int j);
											}

											interface I2 {
												public void sum(int k, int j);
											}
		
		
anonymous method: the process of declaring a method without name is known anonymous method

Lambda expression: the expression which holds functional interface is known Lambda expression

				Syntax: 
				
							(parameter-list)->{
										// statements
									};

functional interface: the interface which is having only one abstract method is known as functional interface.



	EX: 
									
							public class AnonymousMethod {

									public static void main(String[] args) {
										
										I3 i3 = (int k, int h)->{
											System.out.println("Sum of variables : "+ (k+h));
										};
										i3.sum(56, 67);
									}

								}

								@FunctionalInterface
								interface I3{
									public void sum(int k, int g);
								}

								interface I4{
									
									public void sum(int k, int j);
									public void display(String str);
								}
								
								
								
				Note: whenever we use lambda expression that time extra .class files will not be generated.
				
				
private access modifier: 

							1) private variables: can be accessed within the same class.
							2) private methods: can't be overrided
							3) private class: can be declared only as inner class.
							4) private constructor: outside the class we can't create object
													In real time private constructors can be used to create singleton class.
													singleton class: the class which generates only object is known  singleton class.
																	 we can create singleton class using private constructor and provide the static method to get object of that class
											
											
									EX:
											public class PrivateConstructor {

													public static void main(String[] args) {
														
														Test.getObject().m2();
														Test.getObject().m2();
													}

												}


												class Test {
													
													private static Test test= null;
													
													private Test() {
														
													}
													
													
													public static Test getObject() {
														
														if(test == null) {
															test = new Test();
														}
														System.out.println(test.hashCode());
														return test;
														
													}
													
													
													public void m2() {
														System.out.println("From singleton class");
													}
													
												}
												
										hashcode(): can be used to get the address location of object within the heap area.
										
Based access there are two types of objects:
												1) mutable objects: These are objects whose state can be changed 
																	the class can be extended.
																	the class members can be modified
												
												2) immutable objects: These are objects whose state can't be changed 
																	  the class can't be extended.
																	  the class members can't be modified
															
												Ways to create immutable objects:
																					i) create class as final class.
																					ii) create all the members as private and final
																					iii) provide only getter methods to access members of a class
																					
																					
																					
																					
											EX:
											
													public class MutableObjects {

														public static void main(String[] args) {
															
															Example1 obj1 = new Example1();
															obj1.h =56;
															
															Example2 obj2 = new Example2();
															System.out.println(obj2.getM1());
															System.out.println(obj2.getK());
														}

													}


													class Example1{
														
														int h = 78;
														
														
													}

													final class Example2{
														
														private final int k = 67;
														
														private final String m1() {
															return "Java";
														}
														
														public String getM1() {
															return m1();
														}
														
														public int getK() {
															return k;
														}
														
													}
																																
																																
													


CharSequence interface: Used for representing sequence of characters.

		and the classes which implements charSequence interface are below:
			
			
					
					String: String is a class in java and represents sequence of characters
							The objects which are created using String class are immutable objects.that means once declared can't be modified. but we can re-assign.
							All the String objects are created inside String constant pool area which is separately allocated only for String objects inside heap.
							 
							 
							 Ways to create String objects:
																i) using String literal: In this case we declare String objects using double quotes.
																						  syntax or ex:
																											String str = "java";
																						 If we create String objects using literal then only object will be created within SCP only.
																						 if we two String objects having same data then only object will be created and that reference will pointed to all the objects.
																						 In this case while creating objects jvm always checks for existing objects with same data. if yes jvm will not create new object it will return existing object reference.
																						 JVM use SCP for memory optimization.
																
																ii) using new keyword: If we create string object using new keyword then each time jvm will two objects one is in heap area and another one is in SCP, and reference always points to heap area object.
																					   If two objects having same data then also it will create two objects.
																					   If we create String objects using new keyword then jvm will not check for existing object.
																					   and if we want to move String object from heap area to SCP then we can use intern() method.
																					   syntax or ex:
																					   
																										String str = new String("java");
																										
																										
																						EX:
																	public class StringWaysOfCreation {
																			
																			public static void main(String[] args) {
																				
																				
																				String str = "java"; // using literal
																				String str1 = "java";
																				String str2 = "Java";
																				
																				System.out.println(str.hashCode());
																				System.out.println(str1.hashCode());
																				
																				System.out.println(str==str1);
																				System.out.println(str==str2);
																				String str3 = new String("java"); // two objects within in heap and scp
																				String str4 = new String("java"); // one object created within in heap and reference returned from scp as java is already existed.
																				 // two objects will be created one is in heap area and one is in SCP and reference points to heap area object.
																				String str5 = str4.intern(); // moving or pointing reference from SCP
																				String str6 = "java";
																				System.out.println(str5==str6);
																				
																			}

																		}

}
																					
																
					
					
					StringBuffer: StringBuffer class will generate mutable objects.
								  The StringBuffer class is a synchronized hence thread safe
								  The StringBuffer objects are auto growable where as the String objects are fixed in length.
								  The initial capacity of StringBuffer is 16 and if the capacity is full then it will increase the capacity by doubling.
								  Use append() method to add values to the StringBuffer class object.
								  
								  
								  synchronized class:
														The class which is declared using synchronized is known as synchronized cass
														One thread can access the data of sychronized class at a time.
														
					
					
					StringBuilder: The objects which are generated using StringBuilder class are mutable.
								   The StringBuilder class is not sychronized hence not thread safe
								   The initial capacity of StringBuffer is 16 and if the capacity is full then it will increase the capacity by doubling.
								   Use append() method to add values to the StringBuffer class object.
								   
								   
						toString():  this method can be used for String representation of an object.
						
					StringTokenizer: This StringTokenizer class can be used to break the string into multiple tokens or words.
					
							constructors for StringTokenizer: 
																i)StringTokenizer(String str): in this case it will take the default delimeter as space or tab or next line
																
																ii)StringTokenizer(String str, String delimeter): In this case it will use specified delimeter for breaking string into tokens.
																
																iii) StringTokenizer(String str,String delimeter,boolean flag): In this case it will use specified delimeter for breaking string into tokens.
																																if the flag is true then it will consider that delimeter also be a part of tokens.
																																and default flag is false.
								hasMoreTokens(): this method can be loop through all the tokens of String.
								nextToken(): this method can be used to get the tokens of the String.
								
								
			Immuatble Strings:
								The objecs which are crated using String class Are immutable String. that means once cretaed can't be modified
								and if we do so one object will be creaed without reference then eligible for garbage collection.
								
			Memory allocation of strings:
											The String objects which are created using literal then only one object will be created within the SCP.
											The String Objects which are created using new keyword then two objects will be created one is in heap area and one is in SCP and reference points to heap area object.
											if we want to get the String object from SCP then we can use intern() method.
											
											
											
			Note:
					String objects are immutable and fixed in length
					StringBuffer objects are mutable,auto growable and synchronized hence thread safe
					StringBuilder objects are mutable, auto growable but not synchronized hence not thread safe.
					
					
			String class methods: 
			
									EX:
										public class StringMethods {

												public static void main(String[] args) {
													
													String mailId = "svchar4@gmail.com";
													
													String str1 = "java";
													String str2 ="Java";
													String str3 = "java";
													String str = "String MetHods ExaMple";
													System.out.println(str.toLowerCase()); //to convert into lower case
													System.out.println(str.toUpperCase()); //to convert into upper case
													System.out.println(str.charAt(2)); // to get character at specified index.
													System.out.println(str.replace("e", "s")); // to replace single or multiple characters with specified characters
													System.out.println(str.replace("MetHods", "class methods"));// to replace single or multiple characters with specified characters
													System.out.println(str1.equals(str2));// exact match with specified String object
													System.out.println(str1.equals(str3));// exact match with specified String object
													System.out.println(str1.equalsIgnoreCase(str2));// ignore case while comparing String objects.
													System.out.println(str.replaceFirst("e", "k")); // replace only first occurance of the String 
													System.out.println(str.endsWith("s")); // to check whether the string ends with specified String/character or not.
													
													for(int k =0; k<str.length(); k++) { // here length is for finding length of the String.
														System.out.println(str.charAt(k));
													}
													//IntStream chars = str.chars();
													
													System.out.println(str.indexOf("g")); // get index number of specified char/string
													System.out.println(str.indexOf("e"));// get index number of specified char/string
													System.out.println(str.lastIndexOf("e")); // get last index number of specified char/string
													if(mailId.endsWith("gmail.com")) {
														System.out.println("It's the gmail account");
													}
												}

											}
											
											
Exceptions in java:
						
						*) While executing java program there might be some interruption.
						
						there can be two types of interruption in java:
						
						
							1) Exception: Exeception are the unwanted or unexpected events that disturbs the normal flow of the application.
										  If the interruption are handled then we can call them as exceptions.
										  ex: nullPointerException,SQLException IOException etc.
										  
										  
							
							2) Error: Error are the unwanted or unexpected events that disturbs the normal flow of the application.
									  If the interruptions can't be handled then we can call them as errors.
									  
									  EX: virtualMachineError, outOfMemoryError etc.
									  
									 
							Interruptions can be happen for user inputs or system failures.
							
							Note: All the errors and exceptions are raised at runtime. that means while execution of the program.

						Exception handling : the process of handling exceptions is known exception handling.
											 To hande exception we can use try block, catch block, finally block.
											 
											 
											 try : we can place the set of statements which might raise exceptions
												   try block can have the code which can raise exceptions.
												   
												   
											catch: catch block will have the logic to handle exception raised by try block.
												   catch block will execute only if the exception raised in try block.
											
											
											finally: In general finally block will have the statements for closing resorces which are opened in try block.
													 finally block will execute in both cases(even exception raised or not)
													 
													 
							
								EX:
								
										public class ExceptionExample1 {

												public static void main(String[] args) {

													new TestExecption().display();
												}

											}

											class TestExecption{
												
												String str = "tEST";
												
												public void display() {
													Scanner sc = new Scanner(System.in);
													System.out.println("Enter user input");
													
												try {
													try {
														int input = sc.nextInt();
														System.out.println(input);
													} catch (Exception e) {
														System.out.println("Exception while printing user input");
													}
													System.out.println(str.toLowerCase());
												}
												catch (Exception e) {
													System.out.println("Exception while printing str");
												}
												finally {
													sc.close();
													System.out.println("Finally block");
												}
													System.out.println("Method excution completed");
												}
												
												
											}


			Exception hierarchy:
			
			
									Throwable: Throwable is the class which is super/parent class for all the exceptions and errors.
									
									Exception: Exception is the class which extends throwable class and super class for all the exceptions.
									
									Error : Error is the class which extends throwable class and super class for all the errors.
									
									
									
									Exceptions:   Exceptions are events which disturbs normal flow of the application.
									
									
											types of exceptions:
											
											1) Built-in exceptions: The exceptions which are already definedin java known as built-in exceptions
											
											2) User-defined exceptions: the exceptions which declared and defined by programmer known as user-defined exceptions.
											
											
									1) Built-in exceptions: 
											
											1)checked exceptions / compile-time:
											
											2)unchecked exceptions/ runtime:
									
									
									1)checked exceptions / compile-time: The exceptions which are checked/identified by compiler are known as checked exceptions.
									
																		 Ex: IOException, SQLException,InterruptedException,ServletException etc.
																		 
																		 
																		 
									2)unchecked exceptions/ runtime: The exceptions which are not checked or identified by compiler known as unchecked exceptions.

																		Ex: NullPointerException, ClassCastException,ArrayIndexOutOfBoundException,ArithmeticException etc.

									
												
												
							
									Methods to print exception information:
									
									toString(): this method will print name and desciption of the exception.
									
									printStackTrace(): this method will print name,desciption and location of exception(location means where the exception raised in program).
									
									getMessage(): this method will print only desciption of the exception.
									
									
					How JVM will hanle an exception:
																	* if the exception occured inside the method then than will create exception object and handover it ot run time system(JVM).
																	* this exception object will have the information like name, desciption and current state of the program.
																	* creating exception object and handover it runtime system(JVM) is known as throwing an exception.
																	* there might be list of methods that had been called to get  the method where an exception occured. we can call this list as call stack.
																	
																	After above steps jvm will do the following procedure.
																	
																	* Jvm will searches the class stack to find the method that contains block of code that can handle exception. this code we can it as exception handler.
																	* JVM will searches from the method in which the exception is occured and proceeds through the call stack in reverse order.
																	* if JVM finds appropriate handler the it will give that exception object to it. heare the appropriate means type of exception object thrown and exception object matches.
																	* if JVM couldn't find appropriate handler then it will give that exceptio object to DefaultExceptionHandler.
																	* DefaultExceptionHandler will have the information about exception like below.
																	
																	
																			Exception in thread " thread or method info" name of the exception: Description
																			// call stack
									
																			and it will stop the program abnormally.
																			
																		


								Note: try block can't be declared alone. try should be declared along with catch block or with finally block or will both catch and finally blocks.													
								
								try with multi catch block: for single try block we can declare multilevel catch blocks.
																 for multilevel catch blocks we should follow child type of exception object to parent type of exception object.
									
									
				Note: Finally block will always executes even if exception raised or not. 
									  The only situation when the finally block will not be executed is system shutdown or jvm shutdown.
									  If there is a return statement inside try block then first finally block will be executed then return statement.
									  And in general or it's recommanded to can use finally block for closing resources which are opened in try.
									
									
									
								Throws keyword: We can use throws keyword to throw compile-time exception to be handled by caller method.or
												Delegate or forward the exception from method to caller method.
												We can also use throws keyword to throw runtime exception but there is no impact of using throws keyword for runtime.
												This throws keyword can be used along with method signature.
												We can throw multiple exceptions using throws keyword.
												
								try with resources: the resources which are opened along with try block are auto closable.
													try with resources is alternative for finally block.	
			

			   
			   
					User-defined/customized exceptions: the exceptions which are defined by programmer are known as user-defined exceptions.
																	Creating our own exception object and giving it to runtime system is known as throwing a customized exception
												
									
																Steps to create customized exceptions: the user-defined class must extends Exception/RuntimeException class.
																									   the user-defined class must be declared with constructor which accepts String as a argument to pass our own message to exception object.
																									   call super class constructor to pass customized messages to parent class exception object.
																									   use throw keyword to deligate user-defined exception object to runtime system.
			

																Note: In case of built-in exceptions the compiler will create the exception object and handover it runtime system.
																	  But in case of user-defined exceptions we need to create our own exceptions object and handover it runtime system.
																	  to deligate or handovering user-defined exception object we need to use throw keyword.
			   
					
						throws: can be used to throw only built-in exceptions.
								we can throw multiple exceptions at a time.
								throws keyword can be used along with method signature
								can be used to deligate checked exceptions.
								
						throw: can be used to throw only runtime exceptions or user-defined exceptions.
							   can be used only inside the method.
							   can be used to throw only one exception at a time.
							   

					Exceptions in inheritance: 			
					
											* if the parent class method throws any exception then child class overrided method may or may not throws the exception.
											* If the parent class method throws any exception then child class overrided method can throws same type of exception or it's child type of exception.
											* If the parent class method doesn't throwing an exception then child class overrided method also shouldn't throw any checked exception					
											* If the parent class method doesn't throwing an exception then child class overrided method can throw any runtime exception						
					

					
java.io: this package can be used to perform input/output operations 


		Stream: stream is the sequence of data that are read from the source and write into the destination.
		
				Based on the data that the stream can hold streams are two types.
				
				
				1)Character stream:
				
				2) Byte Stream:
				
																
				1)Character stream:	character stream can be used read and write single character.
									
									All the character stream classes are extended from Reader and and Writer abstract class.
									
									
									
								File:  File is the class which refers to the specified file.
										
										Syntax: File f= new File(String filePath);
										
										by the above statement it will not create the file. it will just refers to the specified file.
										to create file we can use createNewFile();
										
																
									EX:					
									public class FileExample {

										public static void main(String[] args) throws IOException {
											
											File f = new File("D:\\Testtsts.java");
											File f1 = new File("D:\\TestDIR");
											System.out.println(f.exists());
											System.out.println(f1.exists());
											if(!f.exists())
											{
												f.createNewFile();
											}
											if(!f1.exists()) {
												f1.mkdir();
											}
											System.out.println(f1.exists());
											System.out.println(f.exists());
											

										}

									}

					
					FileReader: FileReader is the class can be used to read the character of data from source.
					
								Ex:
											public class FileReaderExample {

													public static void main(String[] args) throws IOException {
														
														File f = new File("D:\\Test.java");
														
														try(FileReader fr = new FileReader(f);FileReader fr1 = new FileReader(f); ) {
															char ch [] = new char[400];
															int read = fr.read();
															while(read != -1) {
																System.out.print((char)read);
																read = fr.read();
															}
															fr1.read(ch);
															System.out.println("printing using char array");
															System.out.println(ch);
															/*
															 * for(char c : ch) { System.out.print(c); }
															 */
														} catch (FileNotFoundException e) {
															// TODO Auto-generated catch block
															e.printStackTrace();
														} catch (IOException e) {
															// TODO Auto-generated catch block
															e.printStackTrace();
														}
														

													}

												}
												
								Note: using FileReader we can read character by character to overcome this we can use BufferedReader.
												
						BufferedReader: BufferedReader class extended from Reader class and can be used to read the character data line by line and through buffer.
										Using BufferedReader class we can read the character data line by line.
										
										EX:
											public class BufferedReaderExample {

													public static void main(String[] args) throws IOException {
														
														File f = new File("D:\\Test.java");
														try (BufferedReader br = new BufferedReader(new FileReader(f));){
															String str = br.readLine();
															while(str !=null ) {
																System.out.println(str);
																str = br.readLine();
															}
														} catch (FileNotFoundException e) {
															// TODO Auto-generated catch block
															e.printStackTrace();
														} catch (IOException e) {
															// TODO Auto-generated catch block
															e.printStackTrace();
														}
														
													}

												}
						
						FileWriter: FileWriter class extended from Writer and can be used to write the character data to the destination character by character.
									Using FileWriter if we wan to put new line into the file then we need to \n in each write operation.
									
						
						
									Ex:
											public class FileWriterExample {

													public static void main(String[] args) throws IOException {
														
														File f = new File("D:\\WriterTest.txt");
														if(!f.exists()) {
															f.createNewFile();
														}
														try (FileWriter fw = new FileWriter(f);){
															char ch [] = {'c','t'};
															String str = "java";
															fw.write("test data");
															fw.write("\n");
															fw.write(65);
															fw.write("\n");
															fw.write(ch);
															fw.write("\n");
															fw.write(str);
															fw.flush();
														} catch (IOException e) {
															// TODO Auto-generated catch block
															e.printStackTrace();
														}

													}

												}

					BufferedWriter: BufferedWriter class extended from Writer class and can be used to write character of data to the destination.
									BufferedWriter first will write the data into the internal buffer and upon calling close() or flush() methods will write the data into the destination.
									for new line we can use newLine() method of BufferedWriter.
									using BufferedWriter we can reduce number of communications with destination. but in case of FileWriter each time the writer will communicate with destination.
									
					
									EX:
									
											public class BufferedWriterExample {

													public static void main(String[] args) throws IOException {
														File f = new File("D:\\BufferedWriterExample.txt");
														if(!f.exists()) {
															f.createNewFile();
														}
														try (BufferedWriter bw = new BufferedWriter(new FileWriter(f));){
															char ch [] = {'c','t'};
															String str = "java";
															bw.write("test data");
															bw.newLine();
															bw.write(65);
															bw.newLine();
															bw.write(ch);
															bw.newLine();
															bw.write(str);
															bw.newLine();
															bw.write(65);
															bw.flush();
															System.out.println("Data hs been written");
														} catch (IOException e) {
															// TODO Auto-generated catch block
															e.printStackTrace();
														}
													}

												}
					
					
					PrintWriter: PrintWriter is the advanced writer to writer to the character data into the destination.
								for new line we can use println() method of PrintWriter.
								
								
								
								
						2) Byte Stream: To deal with binary data we can use InputStream and OutputStream classes.
						
						
						
										InputStream: InputStream is from java.io package and can be used to read data in the form of bytes.
													 InputStream can be used to read data byte by byte.
													 InputStream is an abstract class which parent class for all the input Stream classes.
													 
													 
											Some of the sub-classes of InputStream are :
													 
											i)FileInputStream:
											ii)ByteArrayInputStream:
											iii)ObjectInputStream:
														
														
											methods of InputStream:
											
												read(): read one byte of data from the source.
												read(byte[] arr): reads bytes from the source and write into the specified byte array.

										
										
										OutputStream: OutputStream is from java.io package and can be used to write the data into the destination in bytes.
													  OutputStream is an abstract class which parent class for all the Output Stream classes.
													  
													  
													  Some of the sub-classes of OutputStream are :
													  
													  i)FileOutputStream:
													  ii)ByteArrayOutputStream:
													  iii)ObjectOutputStream:
													 
													 
													 methods of OutputStream:
											
												write(): writes the specified byte to the destination or output Stream.
												write(byte[] arr): writes the bytes from the specified array to the output Stream.
												
												
									Serialization: The process of converting object into data into the binary data or byte stream data is known as serialization.
												   For serialization we can use ObjectOutputStream.
												   
												   
									De-Serialization: The process of converting byte stream data or binary data into object data is known as De-serialization.
													  For De-serialization we can use ObjectInputStream.
													  
													  
									Note: While serialization if we don't want any variable not to be serialized then we can  declare that variable as transient.
										  The object which we are using for serialization that class must and should implements Serializable interface
										  
										  
									Serializable : Serializable is the interface which is marker interfaces or empty interface.
													
												Why marker interface when it's not having any methods?
												Ans: to specify functionality or to convey what type of operation we are doing
												Ex: Serializable
									
									Transient : Transient is the keyword.
												The variable which is declared using transient keyword that variable data will not be serialized.
												in this case jvm will assign default value to transient variable in place of original value.
												
												
										Note: In the process of de-serialization one object will be created.
										
								Why to serialize object?
								Ans: To send object data across the network. this is due to through network we can send only binary data.