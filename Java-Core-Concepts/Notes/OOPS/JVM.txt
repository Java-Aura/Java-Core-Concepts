JVM
=========
JDK : java development tool kit. which provides JRE, java compiler and provides the environment necessary to run the java program.
	  JDK is the platform dependent.

JRE: IS the java runtime environment which provides environment to run the java program or application


Definition: JVM stands for java virtual machine and it is a part of JRE.
			It run the java program or application
			JVM will convert the byte code(.class) which is generated by java compiler into machine understandable language.and executes it step by step.
			JVM will follow top-down approach
			The first method will load onto the JVM is main method.
			while execution JVM always first looks for main method and if there is no main method then will get runtime exception.
			The execution starts from main method and will follow top-down approach.
			 main method: 
			 
				public static void main(String[] args) {
						
					// block of statements
					int k=20;
						
					}
					
Note: In other programming languages complier will generate the machine code. but in java the compiler will only generate the bye code(.class) which is input to the JVM

javac : javac is the command to compile the java file and to generate .class file for the java file.

java compiler : java compiler can be used to check compile time exceptions and to generate .class file which is input to JVM for execution.


JVM divided into 3 subsystems:

						1) class loader subsystem.
						2) Run time data area.
						3) Execution engine.
						
		
				1) class loader subsystem: Can be used to load, link and initialize the .class file at runtime not compile time.
				
							ex: 
									
											public class JVMTest {

												public static void main(String[] args) {
													// 
													static int k = 20;
													String str = "test";
													System.out.println(str.hashCode());
													

												}

											}
							
				
						
					Load: in this phase the .class file will be loaded
							
							loading can be done in following class loaders :
							
								i) BootStrap class loaders:  Loads the .class file from rt.jar file and the highest priority is given to this loader.(C:\Program Files\Java\jdk1.8.0_202\jre\lib\rt.jar)
					
								ii) Extension class loader: loads the .class files from ext folder. (C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext)
								
								iii) Application class loader. loads the .class files from application class path.(environment variables)
								
								JVMTest .class file will be loaded
					
					Link: 
							
							Verify: In this stage there byteCode verifier will verify the byte code which generated by java compiler is proper or not.
									If the byte code is not proper will get LinkageError.
							
							Prepare: In this stage all static members will get memory and the static variables assigned with default values.
							
										static int k = 0;
										static String str = "null";
										str : user provided reference
							
							Resolve: All symbolic references are replaced with original reference from method area(class area)
							
									static String str = "null";
									str will be replaced by original reference which hashcode of str(3556498)/ address location.
									
									
								
					
							
					
					Initialize: This is the last stage in class loading and this stage all static blocks will be executed and all static variables are assigned with original value
			
										static int k = 20;
										static String str = "test";
										
										
										
2)Run time data area: this area is divided into five types.

		i)Method area/class area
		ii)Heap area/object area
		iii)Java Stack Area
		iv)PC register area
		v)Native method area

		i)Method area/class area: The area which is specific for class known as class area or method area.
								  Here all static programming components will get the memory.
								  And there can be only one method area per JVM
								  And it is a shared resource.shared among all threads
								  
			Note: While class loading the static programming components will get the memory.
				  Once main method got memory it will be loaded onto java stack area for execution.
				  All static members are loaded onto class area(available at class level) that's why we can access static members directly by class name.
				  In java all programming components are either class level(static) or object level(non-static)
				  
				  
		ii)Heap area/object area: This area is for objects.
								  This is the area where all the objects are created.
								  And there can be only one heap area per JVM
								  And it is a shared resource.shared among all threads
								  
								  Note: While object creation all non-static programming components will get the memory, constructor is executed and non-static blocks will be executed,
								  
			
		iii)Java Stack Area: This is the area where all the methods are executed and the first method copied is main method and execution starts from main method.
							 And for every thread a separate run time stack frame/method frame will be created and for every method call one entry will made on stack frame/method frame
							 And in this stack frame/method frame all local variables will get memory. for this reason local variables are available only inside method.
							 
							Stack frame/ method frame is divided into 3 sub entities.
							
								iii.i) Local variable array: This is related to method and all local variables are stored here.
								
								iii.ii) Operand stack: While method execution if any intermediate operation need to be performed then is operand stack acts as workspace to perform that operation
								
								iii.iii) Frame Data: All the symbols related to methods are stored here and in case of any exception the catch block information will be maintained here.
								
										exception: exception is a event which interrupts or disturbs the program to be executed.
										
										
		iv)PC register area: Each thread will have separate pc register area to hold the address of current execution program.
								once the execution is completed it will hold another execution address
								
								
		v)Native method area: The area where all the native methods are executed is known as Native method area
		
								Native method: the method which is declared using native keyword is known as native method
											  Note: native methods are the methods which are developed in other programming languages not in java
												
												
												
3) Execution engine: The byte code which is copied onto run data time areas is executed by execution engine.
					 The execution engine reads byte code and executes it by step by step.
					 The execution engine has two translators
					 
					 
					Interpreter: Interpreter reads the byte code fastly but executes slowly.
								 whenever we have interpreter while executing program we can accept the request in the middle of the program.
								 If we are calling a method multiple times and each time the interpreter is required
					
					JIT compiler: Just in time compiler and bulk of operations are executed by JIT compiler.
								  if method called multiple times then JIT compiler will use interpreter to reads the byte code and changes into native code,
								  and this native code will be called without  reading again when method called multiple times.
								  
								  intermediate code generator: produce the intermediate code.
								  code optimizer: responsible for optimizing interpreter code.
								  target code generator: responsible for generating machine code or native code.
								  profiler: can be used to identify whether the code called multiple time or not.
								  
								  
								  
JNI: Stands for java native interface, can be used while native methods.
	 And for executing native methods we have native method libraries.

Garbage collector: Collect the objects which are not referenced. can be used for clean-up process.